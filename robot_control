"""joint_rotator_test controller."""

# You may need to import some classes of the controller module. Ex:
#  from controller import Robot, Motor, DistanceSensor
from controller import Robot, Motor
from datetime import datetime
import time
import math
import sympy as sym
import numpy as np
from trans_matrix import FKWB

TIME_STEP = 64

NOW = datetime.now()

# create the Robot instance.
robot = Robot()

baseMotor = robot.getDevice('base') #min:-90, max:90
upperarmMotor = robot.getDevice('upperarm') #min:-90, max:90
forearmMotor = robot.getDevice('forearm') #min:-90, max:90
wristMotor = robot.getDevice('wrist') #min:-90, max:90
rotationalwristMotor = robot.getDevice('rotational_wrist') #min:-90, max:90
sliderMotor = robot.getDevice('slider')

baseSensor = robot.getDevice('base_sensor')
wristSensor = robot.getDevice('wrist_sensor')
rotationalwristSensor = robot.getDevice('rotational_wrist_sensor')

def setPositionSync(motor, sensor, target, delay):
    DELTA = 0.001
    motor.setPosition(target)
    sensor.enable(TIME_STEP)
    effective = None
    while True:
        if robot.step(TIME_STEP) == -1:
            break
        delay -= TIME_STEP
        effective = sensor.getValue()
        if abs(target - effective) <= DELTA or delay <= 0:
            break
    sensor.disable()

def jacobian(q):
    fk = sym.Matrix(FKWB())
    thetaB, theta1, theta2 = sym.symbols('thetaB, theta1, theta2')
    joints = sym.Array([thetaB, theta1, theta2])
    jaco = fk.jacobian(joints)
    jaco = jaco.subs(thetaB, q[0])
    jaco = jaco.subs(theta1, q[1])
    jaco = jaco.subs(theta2, q[2])
    jaco = np.array(jaco, dtype='float64')
    return jaco

def get_ee(q):
    fk = sym.Array(FKWB())
    thetaB, theta1, theta2 = sym.symbols('thetaB, theta1, theta2')
    fk = fk.subs(thetaB, q[0])
    fk = fk.subs(theta1, q[1])
    fk = fk.subs(theta2, q[2])
    fk = np.array(fk, dtype='float64')
    return fk

def get_new_angles(q):
    pg = 0.8
    dg = 0.5
    K_p = np.array([[pg, 0, 0], [0, pg, 0], [0, 0, pg]])
    K_d = np.array([[dg, 0, 0], [0, dg, 0], [0, 0, dg]])
    current_time = time.time()
    global previous_time
    global error
    global final_joints
    global pos_ee, pos_targ, pos_base_abs
    global x_biased, y_biased
    dt = current_time - previous_time
    previous_time = current_time
    pos_ee = get_ee(q)
    #2nd last link = 0.1485
    #last link = 0.13
    #distance from tank = 0.05
    pos_base = pos_base_abs
    pos_targ = np.array([x_biased, y_biased, -0.098071])
    pos_targ = pos_targ - pos_base
    error_d = ((pos_targ - pos_ee) - error) / dt
    error = pos_targ - pos_ee
    J_inv = np.linalg.pinv(jacobian(q))
    dq_d = np.dot(J_inv, (np.dot(K_d, error_d.transpose()) + np.dot(K_p, error.transpose())))
    q_d = q + (dt * dq_d)
    return q_d

final_joints = None
previous_time = time.time()
error = np.array([0.0, 0.0, 0.0])
pos_base_abs = np.array([0.0765488, 0.2035, -0.208071])
x_biased = 0.43 - 0.13 - 0.03
y_biased = 0.1485 + 0.19

#STAGE1#

#pos_base2d = np.array([pos_base_abs[0], pos_base_abs[2]])
#pos_targ2d = np.array([x_biased, -0.288071])
#opposite = pos_targ2d[1] - pos_base2d[1]
#adjacent = pos_targ2d[0] - pos_base2d[0]
#joint1 = math.atan(opposite / adjacent)
#setPositionSync(baseMotor, baseSensor, joint1*-1, 10000)

#STAGE2#

q = np.array([0.0, 0.0, 0.0])
pos_ee = np.array([0.0, 0.0, 0.0])
pos_targ = np.array([10.0, 10.0, 10.0])

while robot.step(TIME_STEP) != -1 and np.linalg.norm(pos_targ - pos_ee) > 0.001:
    joints = get_new_angles(q)
    baseMotor.setPosition(joints[0])
    upperarmMotor.setPosition(joints[1])
    forearmMotor.setPosition(joints[2])
    q = joints
    final_joints = joints

print("Fin2")

#STAGE3#

joint3 = (final_joints[1] + final_joints[2]) * -1
setPositionSync(wristMotor, wristSensor, joint3, 10000)
  
print("Fin3")

#STAGE4#

setPositionSync(rotationalwristMotor, rotationalwristSensor, final_joints[0], 10000)

#STAGE5#

sliderMotor.setPosition(float(0.03))

print("Fin4")



