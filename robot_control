"""joint_rotator_test controller."""

# You may need to import some classes of the controller module. Ex:
#  from controller import Robot, Motor, DistanceSensor
from controller import Robot, Motor
from datetime import datetime
import time
import math
import sympy as sym
import numpy as np
from trans_matrix import FKWB

TIME_STEP = 64

NOW = datetime.now()

# create the Robot instance.
robot = Robot()

baseMotor = robot.getDevice('base') #min:-90, max:90
upperarmMotor = robot.getDevice('upperarm') #min:-90, max:90
forearmMotor = robot.getDevice('forearm') #min:-90, max:90
wristMotor = robot.getDevice('wrist') #min:-90, max:90
rotationalwristMotor = robot.getDevice('rotational_wrist') #min:-90, max:90
sliderMotor = robot.getDevice('slider')

baseSensor = robot.getDevice('base_sensor')
wristSensor = robot.getDevice('wrist_sensor')
rotationalwristSensor = robot.getDevice('rotational_wrist_sensor')

###REDUNDANT CODE SO FAR###
def setPositionSync(motor, sensor, target, delay):
    DELTA = 0.001
    motor.setPosition(target)
    sensor.enable(TIME_STEP)
    effective = None
    while True:
        if robot.step(TIME_STEP) == -1:
            break
        delay -= TIME_STEP
        effective = sensor.getValue()
        if abs(target - effective) <= DELTA or delay <= 0:
            break
    sensor.disable()
###REDUNDANT CODE SO FAR###

def jacobian(q):
    fk = sym.Matrix(FKWB())
    thetaB, theta1, theta2 = sym.symbols('thetaB, theta1, theta2')
    joints = sym.Array([thetaB, theta1, theta2])
    jaco = fk.jacobian(joints)
    jaco = jaco.subs(thetaB, q[0])
    jaco = jaco.subs(theta1, q[1])
    jaco = jaco.subs(theta2, q[2])
    jaco = np.array(jaco, dtype='float64')
    return jaco

def get_ee(q):
    fk = sym.Array(FKWB())
    thetaB, theta1, theta2 = sym.symbols('thetaB, theta1, theta2')
    fk = fk.subs(thetaB, q[0])
    fk = fk.subs(theta1, q[1])
    fk = fk.subs(theta2, q[2])
    fk = np.array(fk, dtype='float64')
    return fk

def get_new_angles(q):
    pg = 0.8
    dg = 0.3
    K_p = np.array([[pg, 0, 0], [0, pg, 0], [0, 0, pg]])
    K_d = np.array([[dg, 0, 0], [0, dg, 0], [0, 0, dg]])
    current_time = time.time()
    global previous_time
    global error
    global final_joints
    global pos_ee, pos_targ, pos_base_abs
    global x_biased, y_biased, z
    dt = current_time - previous_time
    previous_time = current_time
    pos_ee = get_ee(q)
    #2nd last link = 0.1485
    #last link = 0.13
    #distance from tank = 0.05
    pos_base = pos_base_abs
    pos_targ = np.array([x_biased, y_biased, z])
    pos_targ = pos_targ - pos_base
    error_d = ((pos_targ - pos_ee) - error) / dt
    error = pos_targ - pos_ee
    J_inv = np.linalg.pinv(jacobian(q))
    dq_d = np.dot(J_inv, (np.dot(K_d, error_d.transpose()) + np.dot(K_p, error.transpose())))
    q_d = q + (dt * dq_d)
    return q_d

final_joints = None
previous_time = time.time()
error = np.array([0.0, 0.0, 0.0])
pos_base_abs = np.array([0.0765488, 0.2035, -0.208071])

###EDIT THIS TO THE POSITION OF TARGET###################
###INPUT THE "TRANSLATION" VALUES OF TARGET INTO TARG1###
targ1 = np.array([0.427, 0.273, -0.28])
targ_now = targ1
#########################################################
#########################################################

x_biased = targ_now[0] - 0.13 - 0.05
y_biased = targ_now[1] + 0.1485
z = targ_now[2]

#STAGE1#

q = np.array([0.0, 0.0, 0.0])
pos_ee = np.array([0.0, 0.0, 0.0])
pos_targ = np.array([10.0, 10.0, 10.0])

while robot.step(TIME_STEP) != -1 and np.linalg.norm(pos_targ - pos_ee) > 0.001:
    joints = get_new_angles(q)
    baseMotor.setPosition(joints[0])
    upperarmMotor.setPosition(joints[1])
    forearmMotor.setPosition(joints[2])
    forth = (joints[1] + joints[2]) * -1
    wristMotor.setPosition(forth)
    rotationalwristMotor.setPosition(joints[0])
    q = joints
    final_joints = joints

print("Fin1")

#STAGE2#

sliderMotor.setPosition(float(0.05))

print("Fin2")


